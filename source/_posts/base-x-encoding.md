---
title: baseX 编码
date: 2021-11-21 18:40:37
categories: 基础
tags: [C#, encoding, 基础]
typora-root-url: ..
---

大家都知道的，计算机相关学科，在存储数据的时候，每个存储单元的值是由0和1组成的。因为在实现的时候，只要通过记录两个状态就可以了。而这存储单元，我们取名为bit。1 bit有两个值0和1，同样的1 byte有8个bit，2^8=256，也就可以表示256个值了。这些值的排列组合，就可以对不一样的物品，例如图案、符号，人员等大千世界的所有东西进行编号。9527 大家都认识。而基于特定的编号标准对我们人类历史的这样语言文字符号进行编号，一一对应之后，就是所谓的编码。

以上就是我关于编码的理解。

<!-- more -->

## 引子

国际上，计算机可以表示的字符会有一个唯一的编号，我们称之为 Unicode。而对 Unicode 有很多的解释标准，就是所谓的字符的编码，例如最基础的 ASCII、我们国标的 GB2312、最常用的UTF-8等。这些不同的编码方案也会有很多相似之处（例如几乎所有编码在最开始段都是跟ASCII码兼容的，多余的那些知识我就不在这讨论了）。

但很多时候，我们拥有的数据本身，可能没多大意义。有时候我们会有连续的一大片数据，这些数据可能没有在那些标准编码标准中有对应的字符的，如果在程序中，例如 C# 对这些值强行解释为 UTF8，可能就只会得到些问号"?"。例如我们做加密、哈希等对数据打乱后，失去原本的意义的数据。我们要精简的显示， 而不是 `01000110 01110101 01100011 01101011 00100000 01010101` 地显示的话，有什么办法呢？

扯了这么久，终于要扯到正题上了。我们要讨论的就是这些乱值的表示方法。

## 常见base

国际惯例，数据大多都是以 1 byte (8 bit) 为单位传输修改的。为了直观表示这些数据，大家有好几个比较常选择的方案。

**首先 1 byte 可以表示的数据范围**是 `00000000` 到 `11111111`。

### 实现方案的考量

在**容易实现为主要考量**的话，大多会采用 2^n 次方(n 取 8 的 约数 最佳)个符号来表示上面的数据。这个n相当于把 n bit 一组统一一起表示数据。举个例子，上面的 1 byte 数据，可以 2 bit 一组，考虑 用 0, 1, 2, 3 四个字符来表示。那么这2 bit可以表示为：`00->0`， `01->1`，`10->2`，`11->3`。1 byte的数据 按 2 bit 一组的方案表示，从 `00 00 00 00 00 - 11 11 11 11` 改为 `0000 - 3333`。 也就直观多了。

在**让新的表示字符串尽量短为主要考量**的话，大多会采用尽量多的字符来表示数据。 例如 0,1,2,3 就比 0,1 容量大。为了加大容量，可以增加字符数，至于怎么选字符就是你自己做决定了。现有的标准，大多都会选择 简单的 ascii 字母数字来作为容量。 因为 这些数字、字母等，在大多数的字符串编码中，本身只需要 1byte的数据量。其它的，你采用 甲,乙,丙,丁来作为 2bit 一组的表示形式也没有问题(从`00 00 00 00 00 - 11 11 11 11` 改为 `甲甲甲甲 - 丁丁丁丁`) 。但在大部分操作系统都默认采用 UTF-8 编码的情况下，你所需要的 内存空间 就是 0,1,2,3 的两倍。但实际上，上面甲乙丙丁的玩法，也等价于先用0,1,2,3表示后，再用甲乙丙丁替换掉。

但采用的字符数量多了，也会导致繁乱的事情发生，就需要做**特殊策略**来表示数据了。这种得分两种情况来讨论，一种是能够 n bit 一组 表示数据，但 n 不是 8 的约数的情况(例如 3 bit)，另外一种就是最特殊的情况，新的字符容量比较奇怪(例如容量为5，0、1、2、3、4)的时候。不能够刚好地 n bit 一组来表示 1 byte 的数据。

**首先是可以 n bit 一组，但 n 不是8的约数的情况下** 例如 3 bit 一组。这种情况的话，最简单的做法是，**多个 byte 数据一起处理**，最后落单的单独表示。后面位数不够，可能会加些补位符号。例如：
* 3 byte 的数据， 3 bit 一组。`00000000 00000000 00000000 ` 划分为 `000 000 000 000 000 000 000 000` 即: `00000000-77777777`
* 2 byte 的数据， 3 bit 一组。`00000000 00000000` 划分为 `000 000 000 000 000 0` 即: `00000 0 - 77777 1`
* 1 byte 的数据， 3 bit 一组。`00000000` 划分为 `000 000 00`  即: `00 0 - 77 3`

反向解析的时候，也是按照同一个方案。反正最后 还原为 对应的 byte，然后 按照对应的方向解析就可以了。

**最后就是特殊容量的字符表情况下**，作为最复杂的情况。因为无法正好分组表示数据。在做转码的时候，有时需要退位转码。具体方案我会在下次更新此博文的时候，详细说明一下。这语言要组织还是有点难度的。




## 常见的编码方案
根据上面的考虑，目前国际标准，比较常用的 base x 算法一般就是下面几个。我们可以揣摩一下 对应 `x`被选择原因。
![表示方法](/images/posts/base-x-encoding/base-x-list.jpg)

### base 16

大家做 MD5/SHA-1 哈希 的时候，经过经常看到 这个 `e10adc3949ba59abbe56e057f20f883e` 。需要 16个字符容量，刚好**4bit 一组**， 2个字符表示1 byte 数据。实现难度最低，性能最高，**大小写不敏感**。

**字符表**：`0-15` : `0123456789ABCDEF`

下面给一个简单的实现：

```c#
public const int BASE16_L = 0x1;
private static readonly char[] _lowerChars = "0123456789abcdef".ToCharArray();
public const int BASE16_U = 0x2;
private static readonly char[] _upperChars = "0123456789ABCDEF".ToCharArray();
private static string BitConvert(ICollection<byte> bytes, int format)
{
    char[] currChars = format == BASE16_U ? _upperChars : _lowerChars;
    var sb = new StringBuilder(bytes.Count * 2);
    foreach (byte b in bytes)
    {
        sb.Append(currChars[b >> 4]);
        sb.Append(currChars[b & 0xF]);
    }
    return sb.ToString();
}
```



### base 36
很明显，这是在**大小写不敏感**的情况下，采用 0-9 共10个数字，a-z共 26 个 字母的方案。

**字符表**：`0-35` : `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ`



### base 32
**大小写不敏感**，很明显，是在 base 36的降低实现难度采用的一个权衡选择。 字母只使用 a-v共 22 个 字母。去掉那四个字母后，改为 **5bit 一组** 实现编码。

**字符表**：`0-31` : `0123456789ABCDEFGHIJKLMNOPQRSTUV`



### base 62
<a href="https://en.wikipedia.org/wiki/Base62" target="_blank" rel="noopenner">WIKI百科介绍</a>
**大小写敏感**，把26个字母大小写全用上了。一起上。
**字符表**：`0-61` : `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`

目前我项目中使用的 base 62 的编码的实现是由 Github 网友 renmengye 实现的 <a href="https://github.com/renmengye/base62-csharp" target="_blank" rel="noopener">renmengye/base62-csharp</a>。

这个在项目实践中，会比 官方 提供的默认编码工具 base64 更好用。



### base 64

很明显，是在 base 62的降低实现难度采用的一个权衡选择。因为 62 离 64 只差2个字符。 加上这两个字符，可以变为 **6 bit 一组**实现。实现难度要低得多。

标准的 base 64 编码标准，在最后位数不足的时候，会用`=`号来补位。

**字符表**：`0-63` : `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/` 

**注**：在 使用 base 64 编码的时候作为URL参数的时候，+号 在 火狐上可能会被传值为 空格。 在后端获取到数据时需要特殊处理。



### base 58
在 base 62 下，去除了4个容易混淆的字符(0,I,O,o)。方便使用者阅读，剔除歧义。然而，阅读本身**并没有**什么意义。

**字符表**：`0-57` : `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`




### base 其他

目前知道的，有 **base85**，**base91**，**base92**，**base94**

几乎把ASCII 码能用上的都拿来做字符表了，作者怕是个狠人,这种一般不用来做数据数据表示。可能会做为补丁、特殊数据交换之类的。我自己也没太了解，估计后续也不太可能用上，就不深究了。



### base X
这是我这篇博客最终想要在我的示例代码库实现的功能。任意字符表编码。 从某个角度来说，这种不规则的字符表本身，可以当成一个简单的加密解密算法来使用。先留个坑，后续填。(说这种话的人一般没有后续，想要这代码的，欢迎邮件催更)。



## 博文源码

此文章所有代码都放在了我的 github 仓库 [Nieg/codedemo4blog](https://github.com/Nieg/codedemo4blog/tree/main/gh-pages/base-x-encoding/) 下。



